
> We want to measure the memory consumption of NEST.
> > Normally, we use the information in
> > /proc/<PID>/status, namely VmSize.
Right, however, I would boldly claim that this is a mostly meaningless
measure of software memory consumption.

The catch is that, VmSize is a metric of the virtual memory usage of the
entire process (VAS) and it does, as its name implies, measure the total
*address space* that is being used by a process.

Virtual address space
---------------------

As a simple demonstration of how this measure could easily become
misleading let's assume that at some point I malloc() some 10 MiB of
memory in my program. I don't memset() it, however, but only touch a few
hundred kilobytes somewhere at the middle of this block during the
execution of my program, and finally free it sometime before my program
terminates.

Most virtual memory managers only map pages into memory when they have
been written to, so the other processes could have been happily using
most these 10 MiB in the mean time, whereas the VmSize of my process
would have been blown up.

You might think that this example doesn't really make any sense, because
why would a NEST developer do something as crazy as that? However, now
we come to the second problem.

Linked libraries count
----------------------

The *total* address space means that it also includes all shared
libraries that have been linked to the program, which you haven't
written and you don't control.

There are quite a few of those, and remember that the pattern of
allocating pools of reasonably large buffers to avoid reallocations
without initializing them to smear the page faults over the algorithm
runtime etc. is in fact quite common.

Therefore the allocated address space that hasn't yet been dereferenced
may easily add up to dozens of megabytes even if you are not doing
anything like that in *your* program.

Having recollected this, it also becomes clear why VmSize artificially
inflates the memory usage: the thing is that it also includes the shared
allocations of all of the auxiliary libraries linked to NEST, even if
they are already loaded and used by the other processes.

> > Now, on the k computer this always yields the same
> > number and nobody can tell me why. Alternatively,
> > there is /proc/<PID>/statm
Unfortunately, I don't know the details regarding the design of the K
computer, I only know that it's a grandson of the SPARCs I have in the
basement and it's running some kind of a Linux system.

You can easily imagine however, that for some performance reasons they
could have implemented some customizations into the memory management
area and the reported VmSize value has a different meaning.

Considering all of the above, however, I'd like to point out that what
you are most interested in is rather resident set size (RSS), except
that it counts the shared pages multiple times, so in fact the ideal
metric would probably be "private" RSS mappings, i.e. the memory mapped
pages that are exclusively used by our process.

> > According to the manpage of proc the first column
> > should be virtual memory size as well. But - the numbers
> > are different, even on my laptop.
> > A colleague suspected the factor to be the page size,
> > i.e. /proc/<PID>/statm is quantized in pages.
Your colleague is right, the values in /proc/$PID/statm are in fact
expressed in the number of pages.

I don't see any discrepancy here, however, since considering the fact
that the default page size on x86_64 architecture without hugepages is 4
KiB, it perfectly matches the values reported by /proc/$PID/status on my
machine. 

> > However this would yield 2370 byte per page on my
> > machine.
I would expect Fujitsu to be using large pages, but this number is
indeed surprising.

> > Do you have any idea?
If I were you, I would rather collect memory usage statistics
from /proc/$PID/smaps, which has been around since kernel 2.6.16 if I
remember correctly. 

It provides per-mapping data, which, of course is of great interest,
because from this you can estimate private RSS consumed by your
process. 

I do admit, that the file format is slightly confusing, but Ben Maurer
has written a Perl script to parse it which is since being passed on
from one generation of kernel hackers to another.

It requires Linux::Smaps Perl module, but I bundled it together with the
script.

The typical output is:

zaytsev@newpride:~$ perl smem.pl 4523
VMSIZE:      57364 kb
RSS:          5544 kb total
              2820 kb shared
                 8 kb private clean
              2716 kb private dirty

...

>From this you can deduce that this particular instance of Midnight
Commander is roughly using 5 MiB of physical memory, whereas almost 3
MiB of those are allocated by the libraries, most notably libc, slang
and glib, which are shared among the other ~10 instances that I am
running on the same machine.

